import torch
import whisper
from opencc import OpenCC
import requests
import json


def output_string(data):
    # 将字符串分割成单独的JSON对象
    json_objects = data.strip().split('\n')

    # 存储提取的response字段内容
    responses = []

    # 遍历每个JSON对象
    for json_object in json_objects:
        # 解析JSON对象
        obj = json.loads(json_object)

        # 提取response字段
        response = obj.get('response', '')  # 使用get方法，如果不存在则返回空字符串

        # 添加到列表中
        responses.append(response)

    # 给定的字符列表
    python_list = responses
    # print(python_list)

    single_string = ''.join(python_list)
    # print(single_string)
    return single_string


def model_request(prompt: str):
    # 设置 API 的 URL 和你的模型名称
    api_url = "http://127.0.0.1:11434/api/generate"
    model_name = "gemma2:27b"

    # 设置请求的 headers 和 payload
    headers = {
        "Content-Type": "application/json"
    }
    payload = {
        "model": model_name,
        "prompt": prompt,
        "max_tokens": 256  # 你可以根据需要设置最大 token 数量
    }

    # 发送 POST 请求
    response = requests.post(api_url, json=payload, headers=headers)

    # 检查响应状态码
    if response.status_code == 200:
        outcome = output_string(response.text)
        # print(outcome)
        return outcome
    else:
        print("Failed to get a response:", response.status_code)


def voice2txt(voice_path, model_type='small'):
    """

    :param voice_path:
    :param model_type: tiny,base,small,medium,large
    :return:
    """

    dtype = torch.float
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    model = whisper.load_model(model_type)
    result = model.transcribe(voice_path)

    cc = OpenCC("t2s")

    ST = cc.convert(result["text"])

    # 定义要写入文件的字符串
    text_to_save = ST

    # 指定文件名
    save_path = "./data/test.txt"
    with open(save_path, 'w', encoding='utf-8') as file:
        # 写入字符串到文件
        file.write(text_to_save)
    print("完成转换，以保存为txt文件")


def mp2txt():
    voice2txt('./uploads/output_audio.mp3')


def txt2markdown(txt):
    return model_request(
        '把下面{}里的文字整理为Markdown笔记。' + '{' + txt + '}' + '格式要符合有一个大标题和多个小标题的格式')


def txt2title(txt):
    a = '378.9Tb/s！日本是怎么用一根普通光纤，搞出有史以来最快网速的？'
    b = '下载一部4K电影最快可以多久在今天这个答案可能是0.000824秒啥概念呢眨下眼睛的时间大概是0.1秒眨眼的瞬间100多部电影就下好了实现这么离谱网速的是一根普通的光线今年3月日本国家信息通信技术研究所联合了几个科研机构打破了光线传输记录利用现有的光线搞出了378.9TBPS的传输速度这也就比家庭宽带快了1000多万倍吧大家好 这里是亮子卫很难不好奇光线到底是怎么做到越来越快的它的上线到底在哪这是一根普通的家用光线它跟新闻里刷新世界纪录的光线其实没啥区别它们都是很常见的标准单磨光线外面是包层里面是几位米的玻璃丝纤芯利用纤芯和包层折射率的差异光线耗被困在玻璃丝里沿着纤芯中轴线的方向前进长的都差不多传输速度却差了1000多万倍到底是什么在决定光线的传输速度呢你可能听过有人把光线比做信息的高速公路携带着信息的光线号就是在公路上奔驰的汽车公路越宽那肯定能开上路的汽车就越多了这么说没错只不过决定光线这条公路宽度的不是先行的直径而是平谱的宽度等等杀平谱呢如果你的物理知识还没有还给老师的话这张电磁波谱应该还有印象吧光线通信呢主要用的是进红外光之一小段按照波长有短到长它可以进一步被吸分为这几个波段可用的波段越多平谱的宽度就越大这条公路就越宽但是难就难在并不是每个波段都好用都能用比如说一波段就很不走运光线里的杂质倾扬跟离子会引起这个波段强烈的光吸收从而引起信号的衰减直到现在商用的光线普遍只能使用低损号的C波段和L波段所以公路就这么点宽怎么才能实现最大的吞吐量呢但是做道路规划车型的叫车道那信号走的道呢就叫信道了在给定的平谱宽度上我们可以划出几条并行的信道不同的信道只让特定波长的信号通行不过就像车道太窄了容易撞车信道太近了也是一样的不同信道上的信号之间可能会互相干扰所以信道间得留出点间隔1990年中期商用光线刚开始部署时只有8个信道每个间隔20纳米觉着技术的发展现在的信道间隔已经可以压缩的非常非常窄了比如常见的信道间隔已经变成了0.4纳米在C和L波段可以分出230条信道信道密导一定程度就很难继续吸吮下去了但传输容量可以在信道受量不变的情况下再分一倍那怎么做到呢我们知道光波可以有不同的震动方向只朝着某个特定方向震动那就是偏震光我们看3D电影时会用到偏震式的3D眼镜左镜片过滤出的垂直偏震光右镜片过滤出的是水平偏震光最后大脑将两者合成一个立体图像同样利用光的偏震在光线中光信号也可以在垂直和水平两个方向上同时传输并且互不干扰这样光线的传输容量实际上是乘以二的这也就是偏震所用也就是说光线里比头发丝还细的纤细实际上挤满了病情的单车道还是重庆那种很魔幻的3D立体交通前面咱们说的都是什么平谱宽度啊信道啊顶多算搞搞基建沙漠那么宽每年暑期还会堵落坨何况是光线里上百条的信道每条只有几纳米肯定也会发生交通事故从而影响传输速度玻璃这种材质很特殊还记得这个光学实验吗太阳光穿过三棱镜形成一条彩色光带造成色散的是光的波长不同波长的光在玻璃界之里的折射率不同传输速度也不同必然会造成光闷的分散传播而在光线里传输一个信号包含不同波长成分有一个频率范围不同频率成分的波速度不一样有快有慢所以到达终点的时间不一样这就导致最初那个光信号最后变宽了因为光线都很长嘛这些速度差异慢慢的积累最后就是这个信号变宽的非常明显变宽的信号彼此重叠并相互干扰重叠的这部分就是马尖干扰这个时候信号就识别不出来就出现了马东梅现象马东什么马东梅什么东梅马东梅呀那这时候咋办呢安全驾驶我们知道会保持车间距信号也是一样的传输的时候需要留出一些间隔这是一种思路还有一种思路就是错就错了我们把出错的信号再给它纠正过来不就行了这个时候就用到纠错码了因为时间关系光磨块的纠错码这块就不详细展开了感兴趣的小伙伴可以在弹幕里扣个1人多的话我们就单开一起视频讲讲话说回来无论是保持间隔还是用纠错码纠错它其实都浪费了一部分平补资源传会影响到传输速率总之要想不出错信号肯定会被限速也就是存在一个最高车速对于每一个在信道上全速前进的信号都将面临下一个灵魂考问二仙桥大爷和他的三蹦子其实就是一个低频信号传输的数据量有限不说跑不远还容易翻车那怎么才能让大爷的三蹦子多拉一点点呢很简单找一辆半挂车直接拖着这些三蹦子走正没开玩笑我们看个具体的例子吧我向我的朋友发送一段语音电信号会模拟出这段语音的声波这个模拟信号是个低频波跑的慢还容易变形这就需要一个靠谱的长途运输工具半挂车也就是载波来运送他们说白了就是用载波去改变原始的模拟信号的特征让它更适合信道的特性跑得更快更远更好这个过程就叫做调制载波就是可以有高矮胖瘦很多种类型比如说有的可以改变政府有的可以调节频率还有的可以改变波的顺时位置单独使用其中任何一种速度都不会太快但两两联手就非常无敌了比如常用的正交政府调制库姆先用载波调政府再用另一个载波调项位然后把两个调制后的波合成一个信号波传输不过前面说的这个都是模拟信号的调制运输效率不够高这些年已经被淘汰了我们现在普遍使用的是数字调制它比模拟信号调制多了一个非常关键的步骤编码你可以理解为车还是那个车但是车上多了一个收纳大师对车厢里乱七八糟的货物也就是数据重新的分类打包把车里的空间利用到了极致这样车就能多拉一点传输效率也就上去了那么具体是怎么分类和打包呢还是这段语音的模拟信号它会被采样量化成一串零和一的比特流为了方便理解我们就假设它是其中一个零或者一就是一比特如果一个包装装一比特的话这段语音会被打包成八个包裹那如果一个包裹装两比特的话就只需要四个包裹那此时需要四种颜色的包装来区分里面装了什么这一个包裹其实就是一个信号在通信里又叫一马元只不过包裹是用不同的颜色区分马元是用不同的波形来区分包裹里装的越来越多传输效率就会越高这么说吧网速从3G提速到5G仅仅是这个包裹从只能装4比特增加到可以装8比特那我们往包裹里塞的零和一越多传输的速率是不是就可以无限大了还真不是每个马元也就是一个信号都是一个有着特定的政府和项位的波如果我们把它理解为一组坐标从坐标是福质的分量纵坐标是项位分量那么它就是画面中的一个点随着点越来越多排列也就越来越紧凑这意味着啥呢越来越相似了稍微变宽点偏一点就混叠在一起了很容易出错传递不了正确的信息那传输的再快都没什么意义说到这我们会发现有很多东西比如说色散干绕复杂编码带来的石针等等都制约着传输速率传输速率有一个天花板可以逼近但无法突破这个天花板就是相农极限1948年克劳德相农在通信的数学理论这篇论文里指出无论技术怎么发展由于通信系统中的噪声必然存在所以传输系统有一个容量极限它改出了一个极其简洁的公式一句话概括就是这个容量极限C不仅要有大的频谱宽度还要有好的信号质量也就是新造比而这正是数十年来光线传输速度突飞猛进的秘密还记得开头我们提到的打破世界纪录的光线传输速率吗NICT之所以能够达到378.9TBPS的传输速度其中非常重要的一点就是频谱宽度的突破2022年3月这个团队在C和L波段的基础上将S波段纳入其中2023年又加入了一波段最新的这个研究力依旧是顾及重视将O和U波段也纳入其中一共被划出了1505个信道前面我们提到除了C和L波段之外其它的波段各有各的bug都不太好用那它是咋解决的呢一方面它根据每个波段的特性采用了不同的调制和编码技术比如说S、C、L这些损耗低的波段编码就很复杂O、E、U波段相对就简单一些另一方面它采用了一种先进的纠错码技术低密度既有教验来应对传输中的损耗带来的错误最重要的是它们还给每个波段量身定制了光谱整形器和光纤放大器搭配拉曼放大器一起使用光谱整形器就类似于信号灯优化和管理光信号的频率和强度光纤放大器就像沿途中的加油站会给那些半路没有的衰减信号加油传上它们顺利的抵达终点总之啊别管名字是啥它们的作用就只有一个优化和增强光信号这几种技术联合最终使光线的传输速率达到了378.9TBPS不过这些都只是实验势力传输距离仅有50千米的数据新开发的O带和U带的传输速率并不稳定能不能落地成本也是一个需要考量的问题这么看我们离那个上线还很远你可能听说过对于大规模的数据传输来说用卡车直接运硬盘玩爆任何一种传输方式大约在七八年前也就是2016年吧亚马逊就这么干过他有一辆满载优盘的大卡车开到客户的公司楼下将数据拷贝下来然后运到自家的机房上传到云端按当时配备的光线的传输速率传输这100万TB的数据需要很夸张的27年但8辆卡车协作6个月就可以把这100万TB的数据搬完现在光线的传输速度跑赢拉满硬盘狂奔的卡车了吗肯定是跑赢了今年4月诺基亚和芬兰的一个研究机构合作成功在现有的光线上实现了800Gbps1648公里的传输里程过去卡车6个月搬完的数据现在就只需要几个小时就在今年4月亚马逊的这样卡车退役了这或许意味着属于光线的黄金时代才刚刚开始好了这就是本期视频的全部内容了如果这期视频有让你有所收获的话欢迎评论、点赞、转发一键三连我们下期再见拜拜'
    return model_request(
        b+'，可以用一个标题概括为：'+a+'。那么' + txt + '可以用一个标题概括为：')
